Error Check
=====

Summarize the design of the original system

当然可以，以下是一个实用的 「Error Check 整理表模板」，适用于要件定义阶段，帮助你系统性整理并分析原有系统中的错误检查逻辑。

⸻

✅ Error Check 整理表模板（Error Check Inventory Sheet）

编号	功能模块	检查位置	检查内容描述	错误类型	触发条件	错误信息内容	当前是否仍适用	保留/修改/废弃	备注
EC-001	用户注册	输入校验（画面）	用户名不能为空	输入错误	用户名字段为空	“用户名不能为空”	是	保留	必填字段
EC-002	用户注册	DB保存前	用户名已存在	业务规则冲突	DB中存在同名记录	“该用户名已被使用”	是	保留	需唯一
EC-003	报表生成	参数校验（后台）	日期范围不合法	参数错误	结束日期早于开始日期	“开始日期必须早于结束日期”	是	保留	日期顺序
EC-004	订单提交	状态检查	商品库存为0	状态冲突	商品库存 <= 0	“该商品已售罄”	是	保留	关联商品模块
EC-005	文件导入	文件格式验证	不是CSV格式	输入错误	文件扩展名不为.csv	“请上传CSV文件”	否	废弃	新系统改为支持xlsx


⸻

📌 字段说明

字段	说明
编号	为每个 error check 设定唯一 ID，便于追踪
功能模块	所属的业务模块，如“用户注册”、“订单处理”、“报表”等
检查位置	检查发生的位置，如前端画面、后台逻辑、DB层等
检查内容描述	清晰描述系统进行了什么样的检查
错误类型	分类为：输入错误 / 业务规则冲突 / 状态不一致 / 外部系统错误 等
触发条件	满足什么条件时触发该错误
错误信息内容	原系统给用户显示的错误信息（如有）
当前是否仍适用	这个 error check 是否仍符合当前业务需求
保留/修改/废弃	重构时的处理决策
备注	补充说明或与其他模块的关系等


⸻

✅ 使用建议
•	可以用 Excel / Google Sheet 来填，便于排序、分类、过滤
•	每个模块一页，或使用筛选器统一管理
•	与业务方共同review是否保留这些规则

⸻

承知いたしました。旧システムの要件定義段階で実施したエラーチェックの分析結果をまとめるためのテンプレートファイルをご提供します。このテンプレートは、分析から得られた主要な洞察を構造化し、新システムの設計とテストに活用できるように設計されています。

---

# 旧システムエラーチェック分析結果サマリー

## プロジェクト概要
*   **システム名**: [旧システム名]
*   **再構築対象システム名**: [新システム名]
*   **分析期間**: [開始日] ～ [終了日]
*   **目的**: 旧システムのエラーチェックメカニズムを分析し、新システムの要件定義、設計、およびテスト戦略に活用する。

## 分析結果サマリーテーブル

| エラーカテゴリ | 旧システムでのエラー挙動/処理 | 関連する暗黙のビジネスルール/制約 | 新システム設計への影響（エラー処理、データ整合性など） | 新システムテストケースへの活用 | 現代化における優先度（高/中/低） | 備考 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **[例: データ入力検証]** | [例: 特定の文字が入力された場合、システムがクラッシュする] | | [例: 新システムでは、入力フィールドに厳格なデータ型とフォーマット検証を実装する。ユーザーフレンドリーなエラーメッセージを表示し、入力ガイドラインを提供する。] | | 高 | [例: このエラーは過去にデータ破損を引き起こしたため、最優先で対処。] |
| **[例: 業務ロジック]** | [例: 在庫不足時に注文が誤って受け付けられ、負の在庫が発生する] | [例: 注文は在庫がある場合にのみ受け付けられる。在庫は常に非負でなければならない。] | [例: 注文処理フローにリアルタイム在庫チェックを組み込み、トランザクションの原子性を確保する。エラー発生時は注文を拒否し、ユーザーに明確な理由を通知する。] | [例: 在庫がゼロまたは不足している場合の注文、複数ユーザーによる同時注文のテストケースを作成。] | 高 | [例: この問題は顧客満足度と財務に直接影響するため、重要。] |
| **[例: 外部連携]** | [例: 外部決済ゲートウェイからの応答遅延時に、取引がタイムアウトし、ユーザーに不明瞭なエラーが表示される] | [例: 外部サービスとの通信にはタイムアウト処理が必要。取引の最終状態は常に明確であるべき。] | [例: 外部API呼び出しに適切なタイムアウトとリトライメカニズムを実装する。ユーザーには取引の保留状態を通知し、後で確認できるオプションを提供する。] | [例: 外部サービスが応答しない/遅延するシナリオ、ネットワーク障害時のテストケースを作成。] | 中 | [例: ユーザーエクスペリエンスに影響するが、データ整合性への直接的なリスクは低い。] |
| **[例: リソース管理]** | [例: 大量のレポート生成時にメモリ不足エラーが発生し、アプリケーションが強制終了する] | [例: レポート生成はシステムリソースを効率的に使用する必要がある。] | [例: レポート生成処理を最適化し、メモリ使用量を削減する。非同期処理やバッチ処理を導入し、ユーザーへの影響を最小限に抑える。] | [例: 大規模データセットでのレポート生成、複数ユーザーによる同時レポート生成の負荷テストケースを作成。] | 中 | [例: パフォーマンスと可用性に関わるが、頻度は限定的。] |
| **[追加のエラーカテゴリ]** | [旧システムでのエラー挙動/処理] | [関連する暗黙のビジネスルール/制約] | [新システム設計への影響（エラー処理、データ整合性など）] | [新システムテストケースへの活用] | [現代化における優先度（高/中/低）] | [備考] |
|... |... |... |... |... |... |... |

## 分析から得られた主要な洞察

*   **隠れたビジネスルール**: [旧システムのエラーチェックから明らかになった、これまで文書化されていなかった重要なビジネスルールや制約を記述。]
*   **設計への示唆**: [旧システムのエラー処理の課題が、新システムのアーキテクチャ、エラー処理メカニズム、またはデータモデルにどのような影響を与えるかを記述。]
*   **テスト戦略**: [旧システムのエラーシナリオが、新システムのテストカバレッジ（特にエッジケースや回帰テスト）をどのように強化できるかを記述。]
*   **リスク軽減**: [この分析が、新システムにおける潜在的な技術的負債や運用リスクをどのように軽減するかを記述。]

## 次のステップ

*   [このサマリーを基に、新システムの要件定義書にエラー処理要件を組み込む。]
*   [特定された高優先度のエラーシナリオに対する詳細な設計とテスト計画を策定する。]
*   [利害関係者とこの分析結果をレビューし、追加の洞察や確認を得る。]

---

承知いたしました。旧システムの要件定義段階で実施したエラーチェックの分析結果をまとめるための、より詳細なテンプレートファイルをご提供します。データテーブルやフィールド情報、共通のエラー検証方法に関する項目を豊富に追加しました。

---

# 旧システムエラーチェック分析結果サマリー

## プロジェクト概要
*   **システム名**: [旧システム名]
*   **再構築対象システム名**: [新システム名]
*   **分析期間**: [開始日] ～ [終了日]
*   **目的**: 旧システムのエラーチェックメカニズムを詳細に分析し、新システムの要件定義、設計、テスト戦略に活用する。特に、データレベルの課題と共通検証方法に焦点を当てる。

## 1. 分析結果サマリーテーブル

| エラーカテゴリ | 旧システムでのエラー挙動/処理（具体的なエラーメッセージ、発生条件など） | 関連データテーブル/フィールド（影響を受けたテーブル名、フィールド名） | 旧システムでのエラー検証方法（実装されていた検証ロジック、コードスニペットなど） | 関連する暗黙のビジネスルール/制約（エラーから読み取れる業務上の制約） | 新システム設計への影響（エラー処理、データ整合性、UI/UX、API設計、DBスキーマ変更など） | 新システムテストケースへの活用（テストタイプ、具体的なシナリオ、期待結果など） | 現代化における優先度（高/中/低） | 備考（追加情報、過去のインシデント、回避策など） |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **[例: データ入力検証 - フォーマット]** | | `Customers` テーブル, `phone_number` フィールド | [例: 入力値の文字数チェックのみ（数字以外の文字はチェックなし）。] | [例: 電話番号は数字のみで構成され、特定の桁数である必要がある。] | [例: `phone_number` フィールドに厳格な正規表現ベースのフォーマット検証を実装。UI側でリアルタイム入力チェックとユーザーフレンドリーなエラーメッセージ表示。API層でも再検証。] | [例: **単体テスト**: 不正な電話番号フォーマット（文字、記号、桁数不足/超過）入力。**統合テスト**: 電話番号が関連システムに正しく連携されるか。**回帰テスト**: 既存の電話番号データが正しく処理されるか。] | 高 | [例: このエラーは過去に顧客データ破損を引き起こし、サポートコストを増大させた。] |
| **[例: 業務ロジック - 在庫管理]** | [例: 在庫が不足しているにもかかわらず、注文が受け付けられ、`Products` テーブルの `stock_quantity` が負の値になる。エラーログには「在庫不足」と記録されるが、ユーザーには通知されない。] | `Orders` テーブル, `order_quantity` フィールド; `Products` テーブル, `stock_quantity` フィールド | [例: 注文確定後のバッチ処理で在庫数を更新するが、更新前に在庫が負になる可能性をチェックするロジックが欠如。] | [例: 注文は有効な在庫がある場合にのみ受け付けられる。在庫数は常に0以上であるべき。] | [例: 注文処理フローにアトミックな在庫引き当てロジックを組み込み、トランザクションの分離レベルを強化。在庫不足時は注文を拒否し、ユーザーに明確な理由（例: 「在庫が不足しています」）を通知。] | [例: **機能テスト**: 在庫がゼロ/不足している場合の注文、複数ユーザーによる同時注文。**パフォーマンステスト**: 高負荷時の在庫引き当て処理の正確性。] | 高 | [例: 負の在庫は月次決算に影響し、手動でのデータ修正が必要だった。] |
| **[例: データ整合性 - 参照]** | [例: 存在しない `customer_id` を持つ注文レコードが `Orders` テーブルに作成される。これにより、レポート生成時に「顧客情報が見つかりません」エラーが発生。] | `Orders` テーブル, `customer_id` フィールド; `Customers` テーブル, `id` フィールド | [例: `Orders` テーブルへの挿入時に `customer_id` の存在チェックがデータベースレベルで設定されていない（外部キー制約なし）。] | [例: すべての注文は既存の顧客に関連付けられている必要がある。] | | | 高 | [例: 過去のデータクレンジング作業で、多数の孤立した注文レコードが発見された。] |
| **[例: 外部連携 - タイムアウト]** | [例: 外部決済ゲートウェイへのリクエストが一定時間内に応答しない場合、システムがハングアップし、最終的にタイムアウトエラーが発生するが、取引の状態が不明瞭になる。] | `Payments` テーブル, `transaction_status` フィールド; 外部API連携モジュール | [例: 外部API呼び出しにタイムアウト設定はあるが、リトライロジックやフォールバック処理が不十分。] | [例: 外部サービスとの通信はタイムアウト処理が必要。取引の最終状態は常に明確であるべき。] | [例: 外部API呼び出しに指数バックオフ付きのリトライメカニズムを実装。タイムアウト時は取引を「保留中」としてマークし、非同期で状態確認処理を実行。ユーザーには取引の保留状態を通知し、後で確認できるオプションを提供する。] | [例: **統合テスト**: 外部サービスが応答しない/遅延するシナリオ、ネットワーク障害時のテスト。**セキュリティテスト**: 外部連携時のデータ暗号化と認証。] | 中 | [例: ユーザーからの問い合わせが多く、手動での取引状態確認が必要だった。] |
| **[例: リソース管理 - メモリ]** | [例: 月末に大量のデータを含むレポートを生成しようとすると、アプリケーションサーバーでメモリ不足エラーが発生し、アプリケーションが強制終了する。] | `Reports` テーブル, `report_data` フィールド（間接的に）; アプリケーションログ | [例: レポート生成ロジックがデータを一括でメモリにロードするため、大規模データセットに対応できない。] | [例: 大規模なデータ処理はシステムリソースを効率的に使用する必要がある。] | [例: レポート生成処理をストリーミングまたはバッチ処理に最適化し、メモリ使用量を削減。非同期処理を導入し、ユーザーへの影響を最小限に抑える。] | [例: **負荷テスト**: 大規模データセットでのレポート生成、複数ユーザーによる同時レポート生成。**パフォーマンステスト**: メモリ使用量とCPU使用率の監視。] | 中 | [例: レポート生成が完了せず、業務に支障が出たことが複数回あった。] |
| **[例: ユーザーインターフェース - 操作]** | [例: 必須入力項目が未入力のままフォームを送信すると、エラーメッセージが表示されないか、不明瞭なメッセージが表示され、ユーザーが次に何をすべきか分からない。] | UIフォームの各入力フィールド | [例: クライアントサイドでの必須チェックが不十分、またはサーバーサイドでの検証結果がUIに適切に反映されない。] | [例: ユーザーは必須項目をすべて入力する必要がある。システムはユーザーに明確なフィードバックを提供すべき。] | [例: クライアントサイドとサーバーサイドの両方で堅牢な入力検証を実装。必須項目未入力時には、具体的なエラーメッセージを該当フィールドの近くに表示し、ユーザーが修正できるようにガイドする。] | [例: **ユーザビリティテスト**: 必須項目未入力時のUI挙動、エラーメッセージの分かりやすさ。**機能テスト**: すべての必須項目が正しく検証されるか。] | 高 | [例: ユーザーからの問い合わせや、入力ミスによるデータ不整合が頻繁に発生していた。] |
| **[例: セキュリティ - 権限]** | [例: 一般ユーザーが管理者権限が必要な機能（例: ユーザー削除）にアクセスしようとすると、権限エラーが発生するが、エラーメッセージが技術的な詳細を露呈する。] | `Users` テーブル, `role` フィールド; アクセス制御モジュール | [例: 権限チェックは行われるが、エラーハンドリングが不十分で、内部エラーコードやスタックトレースがユーザーに表示される。] | [例: ユーザーは自身の役割に応じた機能のみにアクセスできる。システムはセキュリティ関連のエラーを適切に処理し、機密情報を露呈しない。] | [例: 権限エラー発生時には、一般的な「アクセス拒否」メッセージを表示し、詳細なエラー情報は内部ログにのみ記録する。セキュリティ監査ログを強化。] | [例: **セキュリティテスト**: 各ロールのユーザーが許可されていない機能にアクセスできるか。**侵入テスト**: エラーメッセージからの情報漏洩の可能性。] | 高 | [例: 過去にエラーログからシステム内部構造が推測されるリスクがあった。] |

## 2. 共通エラー検証方法のまとめ

旧システムの設計書やコード分析から抽出された、共通して使用されていたエラー検証方法を以下にまとめます。これらは新システムの設計において、既存の知見を活かしつつ、より堅牢な実装を検討するための出発点となります。

*   **フォーマット検証 (Format Validation)** [1, 2]:
    *   **概要**: データが事前に定義された構造（例: 電話番号の桁数、日付の形式、メールアドレスの`@`とドメインの有無）に従っていることを確認します。
    *   **旧システムでの実装例**: [例: 文字列長チェック、特定の文字セットの許可/禁止。]
*   **範囲/制約検証 (Range and Constraint Validation)** [1, 2]:
    *   **概要**: 数値、日付、その他の値が許容される範囲内にあることを確認します（例: 年齢が負でない、割引率が100%を超えない）。
    *   **旧システムでの実装例**: [例: 数値の最小/最大値チェック、日付の前後関係チェック。]
*   **完全性/存在チェック (Completeness/Presence Check)** [1, 2]:
    *   **概要**: すべての必須フィールドが入力されていることを確認します（例: 注文処理に必要な配送先住所）。
    *   **旧システムでの実装例**: [例: NULL値チェック、空文字列チェック。]
*   **データ型検証 (Data Type Validation)** [1, 2]:
    *   **概要**: 入力値が期待されるデータ型（例: テキスト、数値、日付）であることを確認します。
    *   **旧システムでの実装例**: [例: 型変換試行、数値/非数値判定。]
*   **一貫性検証/クロスフィールド検証 (Consistency/Cross-field Validation)** [1, 2]:
    *   **概要**: 関連するデータが異なるフィールドやレコード間で論理的に一致していることを確認します（例: 顧客住所と郵便番号の一致、出発日が帰着日より前であること）。
    *   **旧システムでの実装例**: [例: 複数フィールド間の条件式評価、関連テーブルのデータ比較。]
*   **パターンマッチング (Pattern Matching)** [2]:
    *   **概要**: データが特定のパターン（例: メールアドレスの正規表現）に合致するかを確認します。
    *   **旧システムでの実装例**: [例: 部分文字列検索、簡易的な正規表現。]
*   **一意性チェック (Uniqueness Check)** [2]:
    *   **概要**: すべてのデータ値が一意であることを確認します（例: 従業員の社会保障番号、注文番号）。
    *   **旧システムでの実装例**: [例: データベースのユニーク制約、コードでの重複チェック。]
*   **ビジネスルール検証 (Business Rule Validation)** [3, 2]:
    *   **概要**: 企業固有のポリシーや価値観に従って、データの正確性と一貫性を確認します。
    *   **旧システムでの実装例**: [例: 特定の業務ロジックに基づく条件分岐、計算結果の検証。]
*   **参照整合性チェック (Referential Integrity Checks)** [4]:
    *   **概要**: データベース内のテーブル間の関係が維持されていることを確認します（例: 外部キー制約）。
    *   **旧システムでの実装例**: [例: データベースの外部キー制約（存在する場合）、アプリケーションコードでの関連データ存在チェック。]
*   **異常検知 (Anomaly Detection)** [5, 4]:
    *   **概要**: データセット内で期待される動作から逸脱する異常なパターンや外れ値を特定します。
    *   **旧システムでの実装例**: [例: 閾値ベースのチェック、統計的平均からの乖離。]
*   **ログ検査 (Log Inspection)** [5]:
    *   **概要**: プロセスログやシステムログをレビューして、エラーを特定、追跡、解決します。
    *   **旧システムでの実装例**: [例: エラーコードの出力、特定イベントのログ記録。]

## 3. 分析から得られた主要な洞察

*   **隠れたビジネスルール**: [旧システムのエラーチェックから明らかになった、これまで文書化されていなかった重要なビジネスルールや制約を記述。特に、データ整合性や業務フローの暗黙の前提について言及。]
*   **設計への示唆**: [旧システムのエラー処理の課題が、新システムのアーキテクチャ、エラー処理メカニズム、データモデル、UI/UX、API設計、セキュリティ設計にどのような影響を与えるかを記述。例えば、より厳格なデータバリデーション層の必要性、ユーザーフィードバックの改善、エラー発生時のシステム挙動の明確化など。]
*   **テスト戦略**: [旧システムのエラーシナリオが、新システムのテストカバレッジ（特にエッジケース、回帰テスト、パフォーマンステスト、セキュリティテスト）をどのように強化できるかを記述。過去の「真の」エラー [6] や「予期せぬ入力」 [7] が、新しいテストケースの作成にどのように役立つかを具体的に記述。]
*   **リスク軽減**: [この分析が、新システムにおける潜在的な技術的負債、運用リスク、データ移行リスクをどのように軽減するかを記述。特に、過去のデータ破損やシステム停止につながったエラーの再発防止策について言及。]
*   **共通方法の再評価**: [旧システムで用いられていた共通検証方法が、新システムでどのように進化させられるか（例: AI/MLを活用したインテリジェントなルール作成 [1]、リアルタイム検証 [1]）について記述。]

## 4. 次のステップ

*   [このサマリーを基に、新システムの要件定義書に詳細なエラー処理要件とデータ検証ルールを組み込む。]
*   [特定された高優先度のエラーシナリオに対する詳細な設計（データモデル、API仕様、UI/UXフローを含む）とテスト計画を策定する。]
*   [利害関係者（ビジネスユーザー、運用担当者、セキュリティ担当者など）とこの分析結果をレビューし、追加の洞察や確認を得る。]
*   [旧システムのコードベースから、特定のエラーチェックに関連する具体的なコードスニペットやデータ定義を抽出し、新システム設計の参考に供する。]
*   [旧システムの運用ログやインシデントレポートをさらに分析し、エラー発生頻度やビジネス影響度に関する定量的なデータを収集する。]

---

